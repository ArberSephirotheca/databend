// Copyright 2021 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::fs::File;
use std::io::Write;
use std::path::Path;

use common_expression::types::DataType;
use common_expression::types::NumberTypeInfo;

pub enum OP {
    Plus,
    Minus,
    Mul,
    Div,
    IntDiv,
    Modulo,

    Super,
}

pub fn codegen_arithmetic_type_v2() {
    let dest = Path::new("src/query/expression/src/types");
    let path = dest.join("arithmetics_type.rs");

    let mut file = File::create(&path).expect("open");
    // Write the head.
    writeln!(
        file,
        "// Copyright 2021 Datafuse Labs.
//
// Licensed under the Apache License, Version 2.0 (the \"License\");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an \"AS IS\" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This code is generated by common/codegen. DO NOT EDIT.
use super::number::Number;

pub trait ResultTypeOfBinary: Sized {{
    type AddMul: Number;
    type Minus: Number;
    type IntDiv: Number;
    type Modulo: Number;
    type LeastSuper: Number;
}}

pub trait ResultTypeOfUnary: Sized {{
    type Negate: Number;

    fn checked_add(self, _rhs: Self) -> Option<Self>;

    fn checked_sub(self, _rhs: Self) -> Option<Self>;

    fn checked_mul(self, _rhs: Self) -> Option<Self>;

    fn checked_div(self, _rhs: Self) -> Option<Self>;

    fn checked_rem(self, _rhs: Self) -> Option<Self>;
}}"
    )
    .unwrap();

    let lhs = vec![
        DataType::UInt8,
        DataType::UInt16,
        DataType::UInt32,
        DataType::UInt64,
        DataType::Int8,
        DataType::Int16,
        DataType::Int32,
        DataType::Int64,
        DataType::Float32,
        DataType::Float64,
    ];
    let rhs = lhs.clone();

    for a in &lhs {
        for b in &rhs {
            let left = a.number_type_info().unwrap();
            let right = b.number_type_info().unwrap();

            let add_mul = arithmetic_coercion(left, right, OP::Plus);
            let minus = arithmetic_coercion(left, right, OP::Minus);
            let intdiv = arithmetic_coercion(left, right, OP::IntDiv);
            let modulo = arithmetic_coercion(left, right, OP::Modulo);
            let least_super = arithmetic_coercion(left, right, OP::Super);

            writeln!(
                file,
                "
impl ResultTypeOfBinary for ({}, {}) {{
    type AddMul = {};
    type Minus = {};
    type IntDiv = {};
    type Modulo = {};
    type LeastSuper = {};
}}",
                to_primitive_str(a.clone()),
                to_primitive_str(b.clone()),
                to_primitive_str(add_mul),
                to_primitive_str(minus),
                to_primitive_str(intdiv),
                to_primitive_str(modulo),
                to_primitive_str(least_super),
            )
            .unwrap();
        }
    }

    for arg in &lhs {
        let negate = neg_coercion(arg.number_type_info().unwrap());

        match negate {
            DataType::Float32 | DataType::Float64 => {
                writeln!(
                    file,
                    "
impl ResultTypeOfUnary for {} {{
    type Negate = {};

    fn checked_add(self, rhs: Self) -> Option<Self> {{
        Some(self + rhs)
    }}

    fn checked_sub(self, rhs: Self) -> Option<Self> {{
        Some(self - rhs)
    }}

    fn checked_mul(self, rhs: Self) -> Option<Self> {{
        Some(self * rhs)
    }}

    fn checked_div(self, rhs: Self) -> Option<Self> {{
        Some(self / rhs)
    }}

    fn checked_rem(self, rhs: Self) -> Option<Self> {{
        Some(self % rhs)
    }}
}}",
                    to_primitive_str(arg.clone()),
                    to_primitive_str(negate),
                )
                .unwrap();
            }

            _ => {
                writeln!(
                    file,
                    "
impl ResultTypeOfUnary for {} {{
    type Negate = {};

    fn checked_add(self, rhs: Self) -> Option<Self> {{
        self.checked_add(rhs)
    }}

    fn checked_sub(self, rhs: Self) -> Option<Self> {{
        self.checked_sub(rhs)
    }}

    fn checked_mul(self, rhs: Self) -> Option<Self> {{
        self.checked_mul(rhs)
    }}

    fn checked_div(self, rhs: Self) -> Option<Self> {{
        self.checked_div(rhs)
    }}

    fn checked_rem(self, rhs: Self) -> Option<Self> {{
        self.checked_rem(rhs)
    }}
}}",
                    to_primitive_str(arg.clone()),
                    to_primitive_str(negate),
                )
                .unwrap();
            }
        }
    }
    file.flush().unwrap();
}

fn to_primitive_str(dt: DataType) -> &'static str {
    match dt {
        DataType::UInt8 => "u8",
        DataType::UInt16 => "u16",
        DataType::UInt32 => "u32",
        DataType::UInt64 => "u64",
        DataType::Int8 => "i8",
        DataType::Int16 => "i16",
        DataType::Int32 => "i32",
        DataType::Int64 => "i64",
        DataType::Float32 => "f32",
        DataType::Float64 => "f64",
        _ => panic!("unsupported data type"),
    }
}

fn arithmetic_coercion(a: NumberTypeInfo, b: NumberTypeInfo, op: OP) -> DataType {
    let is_signed = a.is_signed || b.is_signed;
    let is_float = a.is_float || b.is_float;
    let bit_width = a.bit_width.max(b.bit_width);

    match op {
        OP::Plus | OP::Mul => {
            let info = NumberTypeInfo {
                is_signed,
                is_float,
                bit_width: next_bit_width(bit_width),
            };

            DataType::new_number(info)
        }
        OP::Modulo => {
            if is_float {
                return DataType::Float64;
            }
            let result_is_signed = a.is_signed;
            let right_size = b.bit_width;
            let size_of_result = if result_is_signed {
                next_bit_width(right_size)
            } else {
                right_size
            };

            let info = NumberTypeInfo {
                is_signed: result_is_signed,
                is_float: false,
                bit_width: size_of_result,
            };
            DataType::new_number(info)
        }
        OP::Minus => {
            let info = NumberTypeInfo {
                is_signed: true,
                is_float,
                bit_width: next_bit_width(bit_width),
            };
            DataType::new_number(info)
        }
        OP::Div => DataType::Float64,
        OP::IntDiv => {
            let info = NumberTypeInfo {
                is_signed,
                is_float: false,
                bit_width,
            };
            DataType::new_number(info)
        }
        OP::Super => {
            let info = NumberTypeInfo {
                is_signed,
                is_float,
                bit_width,
            };
            DataType::new_number(info)
        }
    }
}

fn neg_coercion(a: NumberTypeInfo) -> DataType {
    let bit_width = if a.is_signed {
        a.bit_width
    } else {
        next_bit_width(a.bit_width)
    };

    let info = NumberTypeInfo {
        is_float: a.is_float,
        is_signed: true,
        bit_width,
    };
    DataType::new_number(info)
}

const fn next_bit_width(width: u8) -> u8 {
    if width < 64 { width * 2 } else { 64 }
}
